# MyTown 产品设计方案

> **核心理念**: 从开发者玩具到公共物品,循序渐进  
> **定位**: 开源、去中心化、社区驱动的AI小镇模拟器  
> **版本**: v0.1 Draft  
> **日期**: 2025-11-22

---

## 🎯 产品愿景

**MyTown** 是一个开源的AI驱动的虚拟小镇模拟器,让任何人都能创建、运营和连接自己的AI小镇。

这是一个**低成本的社会实验场**,在多样性中观察涌现,探索复杂系统与构建乌托邦的理想场所。每个Agent都可以是理想的自己、真实的自己,或任何你想成为的人。

通过去中心化技术和社区治理,我们构建一个可持续的、隐私优先的AI社会模拟生态系统。

### 核心价值主张

1. **社会实验平台** - 低成本探索社会动力学和复杂系统
2. **自我探索工具** - 通过Agent投射理想或映射真实
3. **开发者友好** - 开源代码,易于学习和扩展
4. **隐私优先** - 所有数据本地存储,用户完全掌控
5. **成本可控** - 混合AI策略,不依赖昂贵的云端API
6. **社区驱动** - 去中心化治理,社区共建共享
7. **可持续发展** - 从玩具到公共物品的渐进式演化

---

## 👥 用户画像

### 主要用户群体

#### 1. **开发者/技术爱好者** (Phase 1-2核心用户)
- **特征**: 熟悉编程,对AI和游戏开发感兴趣
- **需求**: 学习AI Agent架构,实验新想法,贡献代码
- **使用场景**: Fork代码,修改Agent行为,创建自定义小镇主题

#### 2. **AI研究者/学生** (Phase 2-3)
- **特征**: 研究AI社会模拟,需要实验平台
- **需求**: 可定制的Agent行为,数据导出,可复现的实验
- **使用场景**: 研究Agent交互模式,测试新的AI模型

#### 3. **内容创作者** (Phase 3-4)
- **特征**: 游戏玩家,故事创作者,虚拟世界爱好者
- **需求**: 创建有趣的小镇,观察AI角色互动,分享故事
- **使用场景**: 创建主题小镇(如游戏公会、虚拟公司),记录有趣的AI对话

#### 4. **普通用户** (Phase 4+)
- **特征**: 对AI感兴趣,但不懂编程
- **需求**: 简单易用,有趣的体验,社交互动
- **使用场景**: 访问他人的小镇,与AI角色对话,参与社区活动

---

## 🎮 产品形态

### 三端协同设计

```
┌─────────────────────────────────────────────────────┐
│                   MyTown 生态系统                    │
├─────────────────────────────────────────────────────┤
│                                                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────┐ │
│  │ 桌面应用      │  │ Web应用      │  │ 浏览器插件│ │
│  │ (完整功能)    │  │ (浏览/轻交互)│  │ (快捷访问)│ │
│  └──────────────┘  └──────────────┘  └──────────┘ │
│         ↓                  ↓                ↓       │
│  ┌─────────────────────────────────────────────┐   │
│  │          本地数据层 (SQLite)                │   │
│  └─────────────────────────────────────────────┘   │
│         ↓                                           │
│  ┌─────────────────────────────────────────────┐   │
│  │     去中心化存储层 (IPFS/Arweave) [可选]    │   │
│  └─────────────────────────────────────────────┘   │
│         ↓                                           │
│  ┌─────────────────────────────────────────────┐   │
│  │        区块链层 (资产/治理) [可选]          │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
```

### 1. 桌面应用 (Godot)

**定位**: 核心产品,完整功能

**核心功能**:
- ✅ 创建和管理自己的小镇
- ✅ 添加和配置AI Agent
- ✅ 实时观察Agent互动
- ✅ 自定义场景和建筑
- ✅ 本地AI模型集成(Ollama)
- ✅ 数据导出/导入
- ✅ 插件系统(扩展功能)

**技术特点**:
- Godot 4.4原生应用
- 跨平台(Windows/macOS/Linux)
- 本地数据存储
- 支持本地和云端AI模型

### 2. Web应用 (Godot Web导出)

**定位**: 轻量级浏览器,降低使用门槛

**核心功能**:
- ✅ 浏览公开的小镇
- ✅ 与AI Agent简单对话
- ✅ 观看小镇实时状态
- ✅ 社区发现和搜索
- ❌ 不支持创建小镇(需下载桌面版)
- ❌ 不支持复杂编辑

**技术特点**:
- Godot Web导出(WASM)
- 只读模式或轻交互
- 连接到IPFS获取小镇数据

### 3. 浏览器插件

**定位**: 快捷访问和通知

**核心功能**:
- ✅ 快速查看小镇状态
- ✅ 接收小镇事件通知
- ✅ 一键启动桌面应用
- ✅ 社区动态推送

**技术特点**:
- Chrome/Firefox扩展
- 与桌面应用通信
- 轻量级UI

---

## 🎨 用户体验设计

### 核心交互流程

#### 新用户首次体验 (First-Time User Experience)

```
1. 下载桌面应用
   ↓
2. 启动应用,看到欢迎界面
   ↓
3. 选择模板小镇 (例如: "办公室"、"咖啡馆"、"游戏公会")
   ↓
4. 自动生成3-5个预设AI Agent
   ↓
5. 观看Agent自动互动 (引导教程)
   ↓
6. 尝试添加自己的Agent
   ↓
7. 配置AI模型 (本地Ollama或云端API)
   ↓
8. 保存小镇,获得唯一ID
   ↓
9. [可选] 发布到社区
```

#### 日常使用流程

```
启动应用
   ↓
选择小镇 (本地或从IPFS加载)
   ↓
观察Agent互动 / 添加新Agent / 修改场景
   ↓
查看Agent记忆和关系图
   ↓
导出有趣的对话或故事
   ↓
分享到社区
```

### 界面设计原则

#### 1. **简洁优先**
- 默认隐藏高级功能
- 渐进式披露(Progressive Disclosure)
- 清晰的视觉层级

#### 2. **实时反馈**
- Agent状态实时显示
- 对话气泡动画
- 成本实时追踪(如果使用云端API)

#### 3. **可视化**
- Agent关系图谱
- 记忆时间线
- 小镇活动热力图

#### 4. **可定制**
- 主题切换(明暗模式)
- 布局自定义
- 快捷键配置

---

## 🏗️ 核心功能模块

### Phase 1: MVP (开发者玩具)

#### 1.1 基础小镇系统
- [x] 单个小镇场景(办公室主题)
- [x] 3-8个预设AI Agent
- [x] 简单的2D地图和移动
- [x] 本地数据存储(SQLite)

#### 1.2 Agent系统
- [x] Agent基础属性(姓名、职业、性格)
- [x] 简单的记忆系统(最近10条对话)
- [x] 基于LLM的对话生成
- [x] Agent间碰撞触发对话

#### 1.3 AI集成
- [x] 支持OpenAI API
- [x] 支持Ollama本地模型
- [x] 简单的成本追踪

#### 1.4 基础UI
- [x] 主场景视图
- [x] Agent列表
- [x] 对话气泡显示
- [x] 设置面板(API配置)

### Phase 2: 增强Agent智能

#### 2.1 Stanford记忆流系统
- [ ] 观察(Observations)记录
- [ ] 反思(Reflections)机制
- [ ] 规划(Plans)生成
- [ ] 基于重要性/相关性/时效性的检索

#### 2.2 Agent行为系统
- [ ] 自主移动和探索
- [ ] 任务系统(接受、执行、完成)
- [ ] 情绪状态管理
- [ ] 关系网络可视化

#### 2.3 场景系统
- [ ] 时间系统(昼夜循环)
- [ ] 天气系统
- [ ] 场景事件(节日、突发事件)
- [ ] 多场景支持(办公室、咖啡馆、公园)

### Phase 3: 社区和分享

#### 3.1 小镇发布系统
- [ ] 导出小镇配置(JSON)
- [ ] 上传到IPFS
- [ ] 生成分享链接
- [ ] 小镇元数据(标题、描述、标签)

#### 3.2 社区发现
- [ ] 浏览公开小镇
- [ ] 搜索和过滤
- [ ] 评分和评论
- [ ] 热门小镇排行

#### 3.3 Web应用
- [ ] Godot Web导出
- [ ] 只读模式浏览
- [ ] 简单对话交互
- [ ] 社区首页

### Phase 4: 去中心化和Web3

#### 4.1 去中心化存储
- [ ] IPFS集成(小镇数据)
- [ ] Arweave集成(永久存储)
- [ ] 加密用户数据

#### 4.2 区块链集成
- [ ] 小镇NFT(所有权证明)
- [ ] Agent NFT(独特角色)
- [ ] 治理代币(社区投票)
- [ ] 链上资产交易

#### 4.3 去中心化AI
- [ ] 社区AI节点网络
- [ ] P2P模型共享
- [ ] 分布式计算奖励

---

## 💰 成本控制策略

### 混合AI模型策略

```
┌─────────────────────────────────────────────┐
│            AI计算分层策略                    │
├─────────────────────────────────────────────┤
│                                             │
│  简单对话 (80%)                             │
│  ├─ 本地Ollama (Qwen2.5:7B)                │
│  └─ 成本: $0                                │
│                                             │
│  复杂推理 (15%)                             │
│  ├─ 社区AI节点 (共享算力)                   │
│  └─ 成本: 代币奖励                          │
│                                             │
│  高级功能 (5%)                              │
│  ├─ 云端API (GPT-4/Claude)                 │
│  └─ 成本: 用户自付或社区赞助                │
│                                             │
└─────────────────────────────────────────────┘
```

### 成本优化技术

1. **缓存机制**
   - 相似对话模板缓存
   - Agent行为模式缓存
   - 减少重复LLM调用

2. **批处理**
   - 多个Agent对话批量处理
   - 非实时任务延迟执行

3. **智能降级**
   - 本地模型优先
   - 云端API作为备选
   - 用户可配置策略

4. **社区资源池**
   - 社区贡献算力
   - 共享AI模型
   - 代币激励机制

---

## 🔐 隐私和数据策略

### 数据分层存储

```
┌─────────────────────────────────────────────┐
│              数据存储策略                    │
├─────────────────────────────────────────────┤
│                                             │
│  本地存储 (100%隐私)                        │
│  ├─ 所有Agent数据                           │
│  ├─ 对话历史                                │
│  ├─ 用户配置                                │
│  └─ 小镇状态                                │
│                                             │
│  去中心化存储 (加密,可选)                   │
│  ├─ 备份数据 (用户密钥加密)                 │
│  ├─ 公开小镇配置 (明文)                     │
│  └─ 社区共享资源                            │
│                                             │
│  区块链 (公开,仅资产)                       │
│  ├─ 小镇NFT元数据                           │
│  ├─ 资产所有权                              │
│  └─ 治理记录                                │
│                                             │
└─────────────────────────────────────────────┘
```

### 隐私保护原则

1. **本地优先** - 所有核心数据存储在用户设备
2. **用户掌控** - 用户决定是否上传/分享数据
3. **加密存储** - 敏感数据端到端加密
4. **最小化收集** - 不收集不必要的数据
5. **透明公开** - 开源代码,可审计

---

## 🎯 产品差异化

### 与现有项目对比

| 特性 | MyTown | Microverse | AI Town (a16z) | Stanford原版 |
|------|--------|------------|----------------|--------------|
| **开源** | ✅ 完全开源 | ✅ 开源 | ✅ 开源 | ✅ 开源 |
| **去中心化** | ✅ IPFS+区块链 | ❌ 中心化 | ❌ 依赖Convex | ❌ 中心化 |
| **本地AI** | ✅ Ollama支持 | ✅ 支持 | ❌ 仅云端 | ❌ 仅OpenAI |
| **隐私优先** | ✅ 本地存储 | ⚠️ 本地但无加密 | ❌ 云端数据库 | ❌ 本地但无加密 |
| **社区治理** | ✅ DAO治理 | ❌ 无 | ❌ 无 | ❌ 无 |
| **跨平台** | ✅ 桌面+Web | ✅ 桌面+Web | ✅ Web优先 | ❌ 仅桌面 |
| **商业化** | 🔄 社区驱动 | 💰 Steam销售 | 🆓 免费 | 🎓 学术项目 |

### 核心竞争力

1. **真正的去中心化** - 不依赖任何中心化服务
2. **隐私至上** - 用户完全掌控数据
3. **成本可控** - 混合AI策略,不烧钱
4. **社区驱动** - 开放治理,共建共享
5. **可持续发展** - 从玩具到公共物品的清晰路径

---

## 📊 成功指标 (KPIs)

### Phase 1: MVP (3个月)
- [ ] GitHub Stars: 100+
- [ ] 活跃开发者: 5+
- [ ] 成功运行的小镇: 10+
- [ ] 代码贡献者: 3+

### Phase 2: 社区成长 (6个月)
- [ ] GitHub Stars: 500+
- [ ] 月活用户: 100+
- [ ] 公开小镇: 50+
- [ ] 社区AI节点: 5+

### Phase 3: 生态建立 (12个月)
- [ ] GitHub Stars: 2000+
- [ ] 月活用户: 1000+
- [ ] 公开小镇: 500+
- [ ] 商业化小镇: 10+

### Phase 4: 公共物品 (18个月+)
- [ ] 月活用户: 10000+
- [ ] 去中心化节点: 50+
- [ ] DAO治理参与者: 100+
- [ ] 可持续运营

---

## 🎨 视觉设计方向

### 美术风格

**推荐**: 像素艺术 (Pixel Art)

**理由**:
- ✅ 开发成本低
- ✅ 社区易于贡献
- ✅ 怀旧感,吸引开发者
- ✅ 性能好,适合Web导出

**参考**:
- Microverse的LimeZu素材
- Stardew Valley风格
- Undertale风格

### UI设计原则

1. **极简主义** - 减少视觉噪音
2. **信息密度适中** - 不过载
3. **一致性** - 统一的设计语言
4. **可访问性** - 支持色盲模式、大字体

---

## 🚀 产品发布策略

### Phase 1: 内部测试 (1个月)
- 开发者自测
- 修复核心bug
- 完善文档

### Phase 2: 开源发布 (2个月)
- GitHub开源
- 发布到Product Hunt
- 技术博客文章
- 社交媒体宣传

### Phase 3: 社区建设 (3-6个月)
- Discord/Telegram社区
- 定期开发者会议
- 黑客松活动
- 贡献者奖励

### Phase 4: 生态扩展 (6-12个月)
- 插件市场
- 小镇模板库
- 商业化案例
- DAO治理启动

---

## 📝 总结

MyTown的产品设计遵循**循序渐进、社区驱动、隐私优先**的原则,从一个开发者玩具逐步演化为真正的公共物品。

**核心策略**:
1. ✅ 开源代码,降低学习门槛
2. ✅ 本地优先,保护用户隐私
3. ✅ 混合AI,控制运营成本
4. ✅ 社区治理,可持续发展
5. ✅ Web3集成,但不过度依赖

**下一步**: 制定详细的开发计划和技术架构
